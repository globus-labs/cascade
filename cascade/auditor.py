"""Classes used to assess the quality of dynamics performed by surrogate models
and suggest how to improve them"""

import numpy as np
from scipy.stats import multivariate_normal
from ase import Atoms


class BaseAuditor:
    """Auditors to assess trustworthiness a trajectory generated by an ML surrogate

    Auditors are designed to take a segment of a trajectory generated by a
    machine learned surrogate and return two values:
        1) a score (float) that tells us how much we should trust the trajectory
        2) a set of frames in the trajectory that we may wish to investigate further
           to make this decision. This can be accomplished by, for example,
           running higher fidelity calculations on these frames if the trust for
           this trajectory segment is low.
    """

    def audit(self,
              atoms: list[Atoms],
              n_audits: int,
              sort_audits: bool = False) -> tuple[float, list[int]]:
        """Estimate the probability that any atom is off more than threshold and
           the frames with the highest UQ

        Args:
            atoms: list of ase atoms. Should have atoms.info['forces_ens']
                   set by the cascade EnsembleCalculator
            n_audits: number of frames to return
            sort_audits: whether to return frames in decreasing UQ order.
                         If false, uses argpartition which is linear time
        Returns:
            p_any: an estimate of the probability that the forces on any atom in
                   any frame is above the threshold
            audit_frames: indices of the frames with the highest ensemble std,
                          aggregated by max
        """

        raise NotImplementedError()


class RandomAuditor(BaseAuditor):

    def __init__(self, random_state: int | np.random.RandomState = None):
        """Randomly samples frames from a trajectory to be audited and assigns score"""
        if isinstance(random_state, int):
            self.rng = np.random.RandomState(random_state)
        else:
            self.rng = random_state

    def audit(self,
              atoms: list[Atoms],
              n_audits: int,
              sort_audits: bool = False,
              ) -> tuple[float, list[int]]:
        """
        Args:
            atoms: list of ase atoms. Should have atoms.info['forces_ens']
                    set by the cascade EnsembleCalculator
            n_audits: number of frames to return
            sort_audits: in this case does nothing, since there is no UQ order
        Returns:
            p_any: drawn from Unif(0,1)
            audit_frames: indices of the frams that were sampled
        """
        score = self.rng.uniform(0, 1)

        ix = self.rng.choice(a=len(atoms),
                             size=n_audits,
                             replace=False)
        return score, ix


class ForceThresholdAuditor(BaseAuditor):
    """Determines the likelihood all calculations have error below the
    threshold, based on ensemble variance

    Args:
        threshold: in units of force in the simulation
        n_sample: number of samples to take when estimating the probability
                  of error being less than the threshold
    """

    def __init__(self,
                 threshold: float = 1,
                 n_sample: int = 100):
        self.threshold = threshold
        self.n_sample = n_sample

    def audit(self,
              atoms: list[Atoms],
              n_audits: int,
              sort_audits: bool = False) -> tuple[float, list[int]]:

        force_preds = np.asarray([a.calc.results['forces_ens'] for a in atoms])

        # flatten the predictions we have one dim for the ensemble and one for the rest
        # last dim is spatial (3)
        n_frames, n_models, n_atoms, _ = force_preds.shape
        force_preds_flat = force_preds.reshape((n_models, n_frames * n_atoms * 3))

        # build the error distribution
        force_cov = np.cov(force_preds_flat.T)
        force_err_dist = multivariate_normal(cov=force_cov, allow_singular=True)

        # take a sample from the error distribution
        force_var_samples_flat = force_err_dist.rvs(self.n_sample)
        force_var_samples = force_var_samples_flat.reshape((self.n_sample, n_atoms * n_frames, 3))

        # find the magnitude
        force_samples_mag = np.linalg.norm(force_var_samples, axis=-1)

        # the probability that any 1 magnitude exceeds the threshold
        p_any = (force_samples_mag > self.threshold).any(axis=1).mean()

        # get the frames with the highest UQ
        # take std over ens dimension and then max over remaining atom, spatial dims
        max_uq_by_frame = force_preds.std(1).max((1, 2))

        # get the worst frames
        if sort_audits:
            top_uq_ix = np.argsort(max_uq_by_frame)[::-1][:n_audits]
        else:
            top_uq_ix = np.argpartition(max_uq_by_frame, -n_audits)[-n_audits:]
        return p_any, top_uq_ix
