"""Tests for the ensemble-based calculator and auditor"""

from ase import Atoms
from pytest import fixture
from ase.calculators.lj import LennardJones
from functools import partial

import numpy as np

from cascade.calculator import EnsembleCalculator
from cascade.utils import apply_calculator
from cascade.auditor import ForceThresholdAuditor


def sample_diatomic_distances(
        atoms_str: str = 'N2',
        dist_range: tuple = (1.1, 3),
        n: int = 100) -> list[Atoms]:
    """Create a trajectory of a diatomic system with linearly sampled distances
    atoms_str: ase specification of diatomic
    dist_range: (angstroms) range of distances to sample
    n: number of samples
    """
    atoms = Atoms(atoms_str)
    trajectory = []
    x_vals = np.linspace(*dist_range, n)
    for x in x_vals:
        atoms = atoms.copy()
        atoms.set_positions([[0, 0, 0], [x, 0, 0]])
        trajectory.append(atoms)
    return trajectory


@fixture
def trajectories() -> tuple[list[Atoms], list[Atoms], list[Atoms]]:
    """Returns trajectories generated by two lennard jones potentials with
    different parameters and an EnsembleCalculator combining them
    """

    lj1, lj2 = LennardJones(sigma=1, eps=1), LennardJones(sigma=1, epsilon=1.1)
    ens = EnsembleCalculator([lj1, lj2])

    base_traj = sample_diatomic_distances()
    # generate the trajectories
    t_lj1, t_lj2, t_ens = map(partial(apply_calculator, traj=base_traj),
                              [lj1, lj2, ens])
    return t_lj1, t_lj2, t_ens


def test_ensemble(trajectories):
    """A simple test that the ensembling returns the correct average using
    two lennard jones potentials swept over a set of diatomic distances
    """
    t_lj1, t_lj2, t_ens = trajectories
    f_lj1, f_lj2, f_ens = map(
        lambda x: np.asarray([a.calc.results['forces'][0, 0] for a in x]),
        [t_lj1, t_lj2, t_ens])

    # assert that we really get the mean forces
    f_mean = np.vstack([f_lj1, f_lj2]).mean(0)
    assert np.isclose(f_mean, f_ens).all()

    # assert we get the ensemble member forces and they also have the correct values
    f_ens_members = np.asarray([a.info['forces_ens'] for a in t_ens])
    f_ens_lj1 = f_ens_members[:, 0, 0, 0]
    f_ens_lj2 = f_ens_members[:, 1, 0, 0]
    assert np.isclose(f_ens_lj1, f_lj1).all()
    assert np.isclose(f_ens_lj2, f_lj2).all()


def test_threshold_auditor(trajectories):
    """A fairly naive test, just makes sure that the absolute error in forces is
    put in the correct order by the auditor.
    This only works exactly because we have a diatomic system where the UQ
    is perfectly correlated with the error
    (see: 2_cascade/2_prototype-audits.ipynb)
    with """

    t_lj1, t_lj2, t_ens = trajectories
    f_lj1, f_lj2, f_ens = map(
        lambda x: np.asarray([a.calc.results['forces'][0, 0] for a in x]),
        [t_lj1, t_lj2, t_ens])

    auditor = ForceThresholdAuditor(threshold=1)
    p_any, audits = auditor.audit(t_ens, n_audits=100, sort_audits=True)
    abs_error = np.abs(f_lj1 - f_lj2)
    abs_err_argsort = np.argsort(abs_error)[::-1]
    assert (abs_err_argsort == audits).all()
